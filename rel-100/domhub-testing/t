pscreate: directories not supported yet...
--- Makefile	Sun Mar  6 21:29:47 2005
+++ Makefile	Fri Oct 15 02:15:45 2004
@@ -0,0 +1,33 @@
+all: echo-test open-test
+
+echo-test: echo-test.c
+	gcc -o echo-test -Wall echo-test.c
+
+open-test: open-test.c
+	gcc -o open-test -Wall open-test.c
+
+clean:
+	rm -f echo-test open-test
+
+BIN=echo-test open-test
+TESTS=current-test.sh domid-test.sh echo-test.sh echo-throttle-test.sh \
+	fpga-reload-test.sh quiet-test.sh run-test.sh sink-test.sh \
+	slow-open-test.sh softboot-test.sh source-test.sh tcal-test.sh \
+	temp-test.sh wiggle-test.sh wr-block-test.sh throughput.sh
+
+RESULTS=domid-results.sh quiet-results.sh softboot-results.sh \
+	throughput-all-results.sh throughput-AB.sh echo-results.sh \
+	echo-throttle-results.sh sink-results.sh source-results.sh \
+	tcal-results.sh
+QUERIES=details-qry.sh error-qry.sh even-schedule-qry.sh results-qry.sh
+
+install: all
+	@mkdir -p /usr/local/share/domhub-testing
+	install -D $(BIN) $(TESTS) $(RESULTS) $(QUERIES) mjb.sh run-mjb.sh \
+		tests.txt \
+		/usr/local/share/domhub-testing
+	@cd /usr/local/share/domhub-testing; \
+		ln -f throughput-AB.sh throughput-A-results.sh; \
+		ln -f throughput-AB.sh throughput-B-results.sh
+	@mkdir -p /usr/local/bin
+	ln -f /usr/local/share/domhub-testing/run-mjb.sh /usr/local/bin/run-mjb
--- comm-tests	Sun Mar  6 21:29:47 2005
+++ comm-tests	Sat Oct  9 00:04:08 2004
@@ -0,0 +1,48 @@
+FIXME: add names of scripts, required outputs, requirement
+for pass...
+
+wiggle: large wiggles on domA DAC, tests dor/dom state machine robustness.
+make sure the dac stops wiggling for 100ms every 2 seconds so that hw does
+not give up.
+
+echo: stuffing echo test: check throughput, tests sw buffering, fw state
+machine, hw via acceptable crc error rates
+
+echo-throttle: echo test with read throttling on dor side: test dom/dor retx 
+mechanism -- dom/dor stuck rx mechanism
+
+sink: test dor write flow control -- small packets 64 bytes.  the
+dom just sinks data -- check throughput crc errors and retx's.
+
+source: test dom write flow control
+
+wr-block: test dor write flow control, dor data flushing...
+
+fpga-reload: fpga reload test: test reboot grant/request
+
+softboot: test softboot, reboot grant/request
+
+domid: test domid functionality
+
+tcal: test round trip time and rms
+
+slow-open: IC/CI test: test open/close on driver and iceboot->echo-mode,
+ensure connection is asserted within x seconds...
+
+quiet: make sure quiet, open dom does not pick
+up any spurious packets
+
+15) [from john] would like to see an open/close test run 1000 times or 
+more to test for memory leaks as part of MJB ... didn't see the # in 
+your list comm-tests.  NOT DONE YET
+
+current: [from john] dom current readout for 1 or both doms on
+a pair.
+
+temp: temperature test, just records temperature data.
+
+tests should be randomly assigned doms, all doms should
+be busy all the time over the course of the test.  the
+tests should run at -50C and a few other temperatures as
+well, if possible (a ramp would be best)...
+
--- current-test.sh	Sun Mar  6 21:29:47 2005
+++ current-test.sh	Thu Sep  2 01:53:11 2004
@@ -0,0 +1,38 @@
+#!/bin/bash
+
+#
+# current-test.sh
+#
+# output: first_current avg_current rms_current max_dev_current
+# 
+source /usr/local/share/domhub-tools/common.sh
+function atexit () { 
+    rm -f /tmp/ct.$$.*; 
+}
+trap atexit EXIT
+
+dom=$1
+card=`getCard ${dom}`
+pair=`getPair ${dom}`
+for ((i=0; i<1000; i++)); do
+    cat /proc/driver/domhub/card${card}/pair${pair}/current | \
+    awk '{ print $7; }'
+done > /tmp/ct.$$.out
+
+#
+# calculate...
+#
+first=`sed -n '1p' /tmp/ct.$$.out`
+avg=`sed '1!s/$/ +/1' /tmp/ct.$$.out | \
+    awk '{ print $0; } END { print " 3 k 1000 / p"; }' | dc`
+
+rms=`awk -vavg=${avg} \
+    '{ print $1 " " avg " - 2 ^ ";  if (NR>1) print "+"; }' /tmp/ct.$$.out | \
+    awk '{ print $0; } END { print " 3 k 999 / v p "; }' | dc`
+
+maxd=`awk -vavg=${avg} \
+    '{ print $1 " " avg " - 2 ^ p"; }' /tmp/ct.$$.out | dc | sort -r -n | \
+    sed -n '1p' | awk '{ print $0 " v p"; }' | dc`
+
+echo ${dom} ${first} ${avg} ${rms} ${maxd}
+
--- details-qry.sh	Sun Mar  6 21:29:47 2005
+++ details-qry.sh	Mon Sep 13 21:34:00 2004
@@ -0,0 +1,83 @@
+#!/bin/bash
+
+#
+# details-qry.sh, get details on a test given:
+#
+#  testname timestamp dom 
+#
+# we return:
+#
+#   time test took
+#   previous test
+#   tests which ran on the other pair during this time
+# 
+if (( $# != 4 )); then
+    echo "usage: `basename $0` dbfile testname timestamp dom"
+    exit 1
+fi
+
+function atexit () {
+    rm -f /tmp/dq.$$.*
+}
+trap atexit EXIT
+
+#
+# get neighbors first...
+#
+awk -vtime=$3 '{ if ($2>(time-1000) && $2<(time+1000)) print $0; }' $1 > \
+    /tmp/dq.$$.out
+
+#
+# get start time... 
+#
+awk -vdom=$4 -vtime=$3 '{ if ( $3 == dom && $2 < time) print $0; }' \
+    /tmp/dq.$$.out | tail -1 > /tmp/dq.$$.prev
+
+starttime=`awk '{ print $2; }' /tmp/dq.$$.prev`
+prevtest=`awk '{ print $1; }' /tmp/dq.$$.prev`
+
+echo "previous> ${prevtest}"
+let ttime=$(( $3 - ${starttime} ))
+echo "runtime> ${ttime}"
+
+#
+# get tests on the other pair...
+#
+otherdom=`echo $4 | tr '[AB]' '[BA]'`
+
+awk -vdom=${otherdom} '{ if ( $3 == dom ) print $1, $2; }' /tmp/dq.$$.out > \
+     /tmp/dq.$$.others
+
+awk '{ print $2; }' /tmp/dq.$$.others > /tmp/dq.$$.times
+
+sed -n '1!p' /tmp/dq.$$.others | paste -d ' ' - /tmp/dq.$$.times | \
+    awk '{ if (NF==3) print $1, $3, $2; }' > /tmp/dq.$$.setimes
+
+cat <<EOF > /tmp/dq.$$.awk
+{
+   if ( \$3 > stime && \$2 < etime ) {
+      if ( \$2 < stime ) st = stime;
+      else st = \$2;
+    
+      if ( \$3 > etime ) et = etime;
+      else et = \$3;
+      
+      print \$1, et - st; 
+   }
+}
+EOF
+
+awk -vstime=${starttime} -vetime=$3 -f /tmp/dq.$$.awk /tmp/dq.$$.setimes | \
+    awk '{ print "other dom>", $0 }'
+
+#
+# now track down /var/log/messages for this time window...
+#
+# FIXME: too brute force, this should be smarter...
+#
+for (( tm=${starttime}; tm<=$3; tm++ )); do
+    vlm=`awk -vtm=${tm} \
+        'BEGIN { print strftime("%b %e %H:%M:%S", tm); }' /dev/null`
+    grep "^${vlm}" /var/log/messages
+done | awk '{ match($0, "^.*kernel:"); if (RLENGTH>0) print "log> " substr($0, RLENGTH+2); }'
+
--- domid-results.sh	Sun Mar  6 21:29:47 2005
+++ domid-results.sh	Thu Sep 23 20:09:50 2004
@@ -0,0 +1,20 @@
+#!/bin/bash
+
+#
+# domid-results.sh, get results of domid test from db
+#
+verbose=1
+
+if (( $# != 1 )); then
+    echo "usage: `basename $0` dbfile"
+    exit 1
+fi
+
+#
+# make sure domids match...
+#
+if ! awk '{ if ( $4 == "" || $4 != $5 ) { print $0; exit 1; } }' $1; then
+    exit 1
+fi
+
+exit 0
--- domid-test.sh	Sun Mar  6 21:29:47 2005
+++ domid-test.sh	Fri Sep 10 21:21:10 2004
@@ -0,0 +1,26 @@
+#!/bin/bash
+
+#
+# domid-test.sh, do domids match -- are they valid -- are
+# there any duplications?
+#
+# output: procfile_dom_id iceboot_dom_id
+# 
+source /usr/local/share/domhub-tools/common.sh
+#exec 2> /dev/null
+function atexit () { 
+    rm -f /tmp/dit.$$.*; 
+}
+trap atexit EXIT
+
+dom=$1
+card=`getCard ${dom}`
+pair=`getPair ${dom}`
+d=`getDOM ${dom}`
+domid=`cat /proc/driver/domhub/card${card}/pair${pair}/dom${d}/id | \
+    awk '{ print $9; }'`
+domidib=`printf 'send "domid type crlf type\r"\nexpect "^[0-9a-f]+[\r]*$"' | \
+    se ${dom} | tr -d '\r' | egrep '^[0-9a-f]+$'`
+
+echo ${dom} ${domid} ${domidib}
+
--- echo-results.sh	Sun Mar  6 21:29:47 2005
+++ echo-results.sh	Fri Oct 15 00:38:37 2004
@@ -0,0 +1,9 @@
+#!/bin/bash
+
+v=`awk '{ print $8; }' $1 | sort -n -r | sed -n '1p'`
+
+if (( $v > 1 )); then
+	echo "echo: too many crc errors"
+	exit 1
+fi
+
--- echo-test.c	Sun Mar  6 21:29:47 2005
+++ echo-test.c	Thu Sep  2 02:06:22 2004
@@ -0,0 +1,331 @@
+/* echo-test.c, supports:
+ *
+ *   1) full speed stuffing echo mode test (throughput test) -- default
+ *   2) throttled read test (test retx in dor/dom) -- -t
+ *
+ * we assume the doms are already in echo-mode...
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <ctype.h>
+
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/poll.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#define MAXDOMS 64
+
+struct DomBuf {
+   int dom;
+   const char *data;
+   int ndata;
+   struct DomBuf *next;
+};
+
+static struct DomBuf *dbTop = NULL, *dbLast = NULL;
+
+static const char *cpBuf(const char *buf, int n) {
+   char *t = (char *) malloc(n);
+   if (t==NULL) {
+      fprintf(stderr, "echo-test: internal error, unable to cp buf\n");
+      exit(1);
+   }
+   memcpy(t, buf, n);
+   return t;
+}
+
+static void fill(char *buf, int n) {
+   int i;
+   for (i=0; i<n; i++) buf[i] = random();
+}
+
+static void reg(int dom, const char *buf, int nbuf, int *wm, int *rm) {
+   struct DomBuf *db = (struct DomBuf *) malloc(sizeof(struct DomBuf));
+   if (db==NULL) {
+      fprintf(stderr, "echo-test: internal error, unable to malloc dom buf\n");
+      exit(1);
+   }
+   db->dom = dom;
+   db->data = cpBuf(buf, nbuf);
+   db->ndata = nbuf;
+   db->next = NULL;
+   if (dbLast!=NULL) dbLast->next = db;
+   else dbTop = db;
+   dbLast = db;
+   wm[dom]=wm[dom] - 1;
+   rm[dom]=rm[dom] + 1;
+
+#if 0
+   printf("reg: dom=%d, nbuf=%d, rm=%d, wm=%d\n", dom, nbuf, rm[dom], wm[dom]); 
+#endif
+}
+
+static int unreg(int dom, const char *buf, int nbuf, int *wm, int *rm) {
+   struct DomBuf *db, *pdb;
+   for (db=dbTop, pdb=NULL; db!=NULL; pdb=db, db=db->next) {
+      if (db->dom==dom) {
+         int ret = 
+            (db->ndata==nbuf && memcmp(buf, db->data, nbuf)==0) ? 0 : 1;
+         free((char *) db->data);
+         if (pdb!=NULL) pdb->next = db->next;
+         if (db->next==NULL) dbLast = pdb;
+         if (db==dbTop) dbTop = db->next;
+         free(db);
+         rm[dom]--;
+#if 0
+   	 printf("unreg: dom=%d, nbuf=%d, rm=%d, wm=%d\n", 
+		dom, nbuf, rm[dom], wm[dom]);
+#endif
+         return ret;
+      }
+   }
+   fprintf(stderr, "echo-test: no message found\n");
+   return 1;
+}
+
+/* t2 - t1 in s */
+static double diffsec(const struct timeval *t1, const struct timeval *t2) {
+   long long usec1 = t1->tv_usec + t1->tv_sec * 1000000LL;
+   long long usec2 = t2->tv_usec + t2->tv_sec * 1000000LL;
+   return (double) (usec2 - usec1) * 1e-6;
+}
+
+/* should we read throttle? */
+static int readThrottle(int rate, unsigned long long bytes, double sec) {
+   if (rate<=0 || sec==0) return 0;
+   return bytes/sec > rate; 
+}
+
+static int test(int *dfds, const char **doms, int ndoms, int nmsgs, int rdt) {
+   struct pollfd fds[MAXDOMS];
+   int dord = 1;
+   int rmsgs[MAXDOMS];
+   int wmsgs[MAXDOMS];
+   int errs[MAXDOMS];
+   struct timeval stv;
+   struct timeval etv[MAXDOMS];
+   unsigned long long bytes[MAXDOMS];
+   int i;
+   int tmout = (rdt>0) ? 100 : -1;  /* recalc 10x a sec if read throttling */
+   
+   for (i=0; i<ndoms; i++) {
+      rmsgs[i] = 0;
+      wmsgs[i] = nmsgs;
+      errs[i] = 0;
+      bytes[i] = 0ULL;
+   }
+
+   /* clear pending msgs... */
+   for (i=0; i<ndoms; i++) {
+	fds[i].fd = dfds[i];
+	fds[i].events = POLLIN;
+   }
+   while (poll(fds, ndoms, 200)>0) {
+	char buf[4092];
+        int i;
+        for (i=0; i<ndoms; i++) {
+	   if (fds[i].revents&POLLIN) read(fds[i].fd, buf, sizeof(buf));
+	}
+   }
+	
+   /* go! */
+   gettimeofday(&stv, NULL);
+
+   while (1) {
+      int nfds=0;
+      int i;
+      int pret;
+      struct timeval ctv;
+      int nrem = 0;
+
+      gettimeofday(&ctv, NULL);
+
+      for (i=0; i<ndoms; i++) {
+	 /* number of messages remaining to send/rcv */
+         nrem += rmsgs[i] + wmsgs[i];
+
+         if (dfds[i]!=-1) {
+            /* FIXME: read throttling? */
+            const int throttle = 
+               readThrottle(rdt, bytes[i], diffsec(&stv, &ctv));
+            if ((!throttle && dord && rmsgs[i]>0) || wmsgs[i]>0) {
+               fds[nfds].fd = dfds[i];
+               fds[nfds].events = 0;
+               if (!throttle && dord && rmsgs[i]>0) fds[nfds].events |= POLLIN;
+               if (wmsgs[i]>0) fds[nfds].events |= POLLOUT;
+
+#if 0
+		printf("setup: dom=%d, rmsgs=%d, wmsgs=%d, in=%d out=%d\n",
+		i, rmsgs[i], wmsgs[i], fds[nfds].events&POLLIN, 
+		fds[nfds].events&POLLOUT);
+#endif
+               nfds++;
+            }
+
+            /* no more msgs to read or write for this dom... */
+            if (wmsgs[i]==0 && rmsgs[i]==0) {
+               gettimeofday(etv+i, NULL);
+               close(dfds[i]);
+               dfds[i] = -1;
+            }
+         }
+      }
+
+      /* all done? */
+      if (nrem==0) break;
+
+      if ((pret=poll(fds, nfds, tmout))<0) {
+         perror("echo-test: poll");
+         return 1;
+      }
+      else if (pret==0) {
+         /* timeout -- we can read again... */
+         dord = 1;
+      }
+
+      for (i=0; i<nfds; i++) {
+         if (fds[i].revents&(POLLIN|POLLOUT|POLLHUP)) {
+            int j;
+         
+            for (j=0; j<ndoms; j++) {
+               if (dfds[j]==fds[i].fd) {
+                  char buf[4092];
+                  
+                  if ( (fds[i].revents&POLLOUT) && wmsgs[j]>0) {
+                     /* do write... */
+                     const int nw = (random()%4091)+1;
+                     int ret;
+                     
+                     fill(buf, nw);
+                     if ((ret=write(dfds[j], buf, nw))!=nw) {
+                        if (ret<0) {
+                           fprintf(stderr, "echo-test: write to %s: %s\n",
+                                   doms[j], strerror(errno));
+                        }
+                        else if (ret==0) {
+                           fprintf(stderr, "echo-test: eof on write to %s\n",
+                                   doms[j]);
+                        }
+                        else {
+                           fprintf(stderr, "echo-test: partial write on %s\n",
+                                   doms[j]);
+                           bytes[j]= bytes[j] + ret;
+                           reg(j, buf, ret, wmsgs, rmsgs);
+                        }
+                     }
+                     else {
+                        /* write succeeded */
+                        bytes[j]= bytes[j] + nw;
+                        reg(j, buf, nw, wmsgs, rmsgs);
+                     }
+                  }
+                  if (fds[i].revents&POLLIN) {
+                     /* do read, verify... */
+                     const int nr = read(dfds[j], buf, sizeof(buf));
+                     if (nr<0) {
+                        fprintf(stderr, "echo-test: read from %s: %s\n",
+                                doms[j], strerror(errno));
+                     }
+                     else if (nr==0) {
+                        fprintf(stderr, "echo-test: eof on read from %s\n",
+                                doms[j]);
+                     }
+                     else {
+                        bytes[j] = bytes[j] + nr;
+                        if (unreg(j, buf, nr, wmsgs, rmsgs)) {
+                           fprintf(stderr, 
+                                   "echo-test: mismatch on read from %s\n",
+                                   doms[j]);
+                        }
+                     }
+                  }
+                  if (fds[i].revents&POLLHUP) {
+                     /* deal with error... */
+                     fprintf(stderr, 
+                             "echo-test: error on read from %s -- closing\n",
+                             doms[j]);
+                     /* close this guy... */
+                     close(dfds[j]);
+                     dfds[j]=-1;
+                  }
+               }
+            }
+         }
+      }
+   }
+
+   for (i=0; i<ndoms; i++) {
+      /*    dom   nbytes time errs */
+      printf("%s %llu %f %d\n",
+      doms[i], bytes[i], diffsec(&stv, etv+i), errs[i]);
+   }
+   
+   return 0;
+}
+
+static void usage(void) {
+   fprintf(stderr, "usage: echo-test [-t rate|-n nmsgs] doms...\n");
+}
+
+int main(int argc, char *argv[]) {
+   int ai;
+   int ndoms = 0;
+   int fds[MAXDOMS];
+   int nmsgs=1000;
+   const char *doms[MAXDOMS];
+   int rdthrottle = -1; /* read throttle data rate in bytes/sec */
+
+   for (ai=1; ai<argc; ai++) {
+      if (strcmp(argv[ai], "-t")==0 && ai<argc-1) {
+         rdthrottle = atoi(argv[ai+1]);
+         ai++;
+      }
+      else if (strcmp(argv[ai], "-n")==0 && ai<argc-1) {
+         nmsgs = atoi(argv[ai+1]);
+         ai++;
+      }
+      else if (strlen(argv[ai])==3) {
+         /* open dom... */
+         char path[128];
+         char dom[4];
+
+         strcpy(dom, argv[ai]);  
+         dom[2] = toupper(dom[2]);
+         snprintf(path, sizeof(path), "/dev/dhc%cw%cd%c", dom[0], dom[1], 
+            dom[2]);
+         if ((fds[ndoms]=open(path, O_RDWR))<0) {
+            fprintf(stderr, "echo-test: open '%s': %s\n", path, 
+                    strerror(errno));
+            return 1;
+         }
+         doms[ndoms] = strdup(dom);
+         ndoms++;
+      }
+      else {
+         usage();
+         return 1;
+      }
+   }
+
+   if (ndoms==0) {
+      usage();
+      return 1;
+   }
+   
+   if (test(fds, doms, ndoms, nmsgs, rdthrottle)) {
+      fprintf(stderr, "echo-test: unable to complete test\n");
+      return 1;
+   }
+
+   return 0;
+}
+
+
+
+
+
+
--- echo-test.sh	Sun Mar  6 21:29:47 2005
+++ echo-test.sh	Wed Sep  1 21:29:01 2004
@@ -0,0 +1,29 @@
+#!/bin/bash
+
+#
+# echo-test.sh:
+#
+#  dom nbytes seconds nretx ncrcerrs
+#
+source /usr/local/share/domhub-tools/common.sh
+dom=$1
+
+# reset comm stats...
+card=`getCard ${dom}`
+pair=`getPair ${dom}`
+d=`getDOM ${dom}`
+procfile="/proc/driver/domhub/card${card}/pair${pair}/dom${d}/comstat"
+
+echo 'reset' > ${procfile}
+
+res=`./echo-test -n 1000 ${dom}`
+
+if (( $? > 0 )); then
+    exit 1
+fi
+
+retx=`cat ${procfile} | tr ' ' '\n' | tr '=' ' ' | awk '/^RESENT / { print $2; }'`
+err=`cat ${procfile} | tr ' ' '\n' | tr '=' ' ' | awk '/^BADPKT / { print $2; }'`
+
+echo ${res} ${retx} ${err}
+
--- echo-throttle-results.sh	Sun Mar  6 21:29:47 2005
+++ echo-throttle-results.sh	Fri Oct 15 00:38:37 2004
@@ -0,0 +1,9 @@
+#!/bin/bash
+
+v=`awk '{ print $8; }' $1 | sort -n -r | sed -n '1p'`
+
+if (( $v > 1 )); then
+	echo "echo-throttle: too many crc errors"
+	exit 1
+fi
+
--- echo-throttle-test.sh	Sun Mar  6 21:29:47 2005
+++ echo-throttle-test.sh	Wed Sep  1 21:57:17 2004
@@ -0,0 +1,29 @@
+#!/bin/bash
+
+#
+# echo-test.sh:
+#
+#  dom nbytes seconds nretx ncrcerrs
+#
+source /usr/local/share/domhub-tools/common.sh
+dom=$1
+
+# reset comm stats...
+card=`getCard ${dom}`
+pair=`getPair ${dom}`
+d=`getDOM ${dom}`
+procfile="/proc/driver/domhub/card${card}/pair${pair}/dom${d}/comstat"
+
+echo 'reset' > ${procfile}
+
+res=`./echo-test -n 500 -t 10000 ${dom}`
+
+if (( $? > 0 )); then
+    exit 1
+fi
+
+retx=`cat ${procfile} | tr ' ' '\n' | tr '=' ' ' | awk '/^RESENT / { print $2; }'`
+err=`cat ${procfile} | tr ' ' '\n' | tr '=' ' ' | awk '/^BADPKT / { print $2; }'`
+
+echo ${res} ${retx} ${err}
+
--- error-qry.sh	Sun Mar  6 21:29:47 2005
+++ error-qry.sh	Mon Sep 13 21:34:00 2004
@@ -0,0 +1,25 @@
+#!/bin/bash
+
+# error-details-qry, get details in errors...
+testnm=""
+while /bin/true; do
+    if [[ $1 == "-t" ]]; then
+        testnm="$2 "
+        shift
+    else
+        break
+    fi
+    shift 
+done
+
+
+if (( $# != 1 )); then
+    echo "usage: `basename $0` dbfile"
+    exit 1
+fi
+
+grep 'ERROR' $1 | grep "^${testnm}" | awk '{print $1, $2, $3; }' | \
+    while read line; do \
+        echo ${line}; ./details-qry.sh $1 `echo ${line}`; echo " "; \
+    done
+
--- even-schedule-qry.sh	Sun Mar  6 21:29:47 2005
+++ even-schedule-qry.sh	Thu Sep 23 20:08:53 2004
@@ -0,0 +1,24 @@
+#!/bin/bash
+
+#
+# even-schedule-qry.sh, do the doms appear to
+# get evenly scheduled?
+#
+function atexit () {
+    rm /tmp/esq.$$.out
+}
+trap atexit EXIT
+
+if (( $# != 1 )); then
+  echo "usage: `basename $0` dbfile"
+  exit 1
+fi
+
+awk '{ print $3; }' $1 > /tmp/esq.$$.out
+
+doms=`sort /tmp/esq.$$.out | uniq | tr '\n' ' '`
+echo "doms=${doms}"
+for d in ${doms}; do
+    echo ${d} `grep "^${d}$" /tmp/esq.$$.out | wc -l | awk '{ print $1; }'`
+done
+
--- fpga-reload-test.sh	Sun Mar  6 21:29:47 2005
+++ fpga-reload-test.sh	Mon Sep 13 21:30:18 2004
@@ -0,0 +1,18 @@
+#!/bin/bash
+
+#
+# fpga-reload-test.sh
+#
+# output: iterations errors
+# 
+errs=0
+for (( i=0; i<100; i++ )); do
+    printf 'send "s\" iceboot.sbi\" find if fpga endif\r"\nexpect "^> "\n' | \
+        se $1 >& /dev/null
+    status=$?
+    if (( ${status} != 0 )); then
+       let errs=$(( ${errs} + 1 ))
+    fi
+done
+
+echo $1 $i $errs
--- last-run.sh	Sun Mar  6 21:29:47 2005
+++ last-run.sh	Thu Sep 23 20:09:50 2004
@@ -0,0 +1,7 @@
+#!/bin/bash
+
+#
+# get the most recent run...
+#
+find mjb-output -type f -print | egrep '^mjb-output/[0-9]+.dat$' | tail -1
+
--- mjb.sh	Sun Mar  6 21:29:47 2005
+++ mjb.sh	Mon Sep 13 21:32:10 2004
@@ -0,0 +1,233 @@
+#!/bin/bash
+
+#
+# mjb.sh, mexican jumping bean tests.  run a bunch of
+# small tests on random doms.
+#
+# great name (mjb) is due to john jacobsen...
+#
+source /usr/local/share/domhub-tools/common.sh
+exec 2> /dev/null
+
+# we need job control on...
+set -m
+RANDOM=0
+
+#
+# cleanup...
+#
+rm -f /tmp/mjb.$$.*
+longtermpid=0
+function atexit() {
+    if (( ${longtermpid} != 0 )); then
+        kill ${longtermpid}
+        longtermpid=0
+    fi
+
+    for pidf in `find /tmp -name 'mjb.$$.*.pid' -print | tr '\n' ' ' `; do
+        pid=`cat ${pidf}`
+	echo "killing ${pid}..."
+        massacre ${pid}
+        echo "waiting for ${pid}..."
+        wait ${pid} 
+    done
+    rm -f /tmp/mjb.$$.*
+}
+trap "atexit" EXIT
+
+function usage () { 
+    local nm=`basename $0`
+    echo "usage:" \
+        "${nm} [-s seconds|-m minutes|-h hours|--no-throughput] (all|CWD...)"
+    exit 1
+}
+
+#
+# seconds is how long we run the tests...
+#
+nothroughput=0
+let seconds=$(( 8 * 60 * 60 ))
+while /bin/true; do
+    if echo $1 | grep '^-' >> /dev/null; then
+        if [[ $1 == "-s" && $2 != "" ]]; then
+            shift
+            seconds=$1
+        elif [[ $1 == "-m" && $2 != "" ]]; then
+            shift
+            let seconds=$(( $1 * 60 ))
+        elif [[ $1 == "-h" && $2 != "" ]]; then
+            shift
+            let seconds=$(( $1 * 60 * 60 ))
+        elif [[ $1 == "--no-throughput" ]]; then
+            nothroughput=1
+        elif [[ $1 == "-h" ]]; then
+            usage
+            exit 0
+        else
+            usage
+            exit 0
+        fi 
+   	shift 
+    else
+        break
+    fi
+done
+
+if (( $# < 1 )); then usage; fi
+
+doms=`getDomList $*`
+
+if (( ${#doms} == 0 )); then
+    echo "`basename $0`: no doms found"
+    exit 1
+fi
+
+#
+# move doms into iceboot and get version info
+#
+versions ${doms} > /tmp/mjb.$$.out
+vdoms=`awk '{ print $1; }' /tmp/mjb.$$.out | tr '\n' ' '`
+
+#
+# make sure all doms are there...
+#
+tdoms=${doms}
+for d in ${vdoms}; do
+    tdoms=`echo ${tdoms} | sed "s/${d}//1" | sed 's/  / /1' | \
+       sed 's/^ //1' | sed 's/ $//1'`
+done
+
+if (( ${#tdoms} != 0 )); then
+   echo "`basename $0`: can not find version info for all doms"
+   echo "  did not find: ${tdoms}"
+   awk '{ print "    found> " $0; }' /tmp/mjb.$$.out
+   exit 1
+fi
+
+#
+# print version info...
+#
+gawk '{ print "versions " systime() " " $0; }' /tmp/mjb.$$.out
+
+#
+# start throughput tests...
+#
+if (( $nothroughput == 0 )); then
+    echo-mode -q ${doms}
+    ./throughput.sh ${doms} | \
+        gawk '{ print "throughput-all " systime() " " $0; }'
+
+    adoms=`echo ${doms} | tr ' ' '\n' | grep '..A' | tr '\n' ' ' | \
+        sed 's/ $//1'`
+    if (( ${#adoms} > 0 )); then
+        ./throughput.sh ${adoms} | \
+            gawk '{ print "throughput-A " systime() " " $0; }'
+    fi
+
+    bdoms=`echo ${doms} | tr ' ' '\n' | grep '..B' | tr '\n' ' ' | \
+        sed 's/ $//1'`
+    if (( ${#bdoms} > 0 )); then
+        ./throughput.sh ${bdoms} | \
+            gawk '{ print "throughput-B " systime() " " $0; }'
+    fi
+fi
+
+#
+# start watchdog...
+#
+( sleep ${seconds}; ) >& /dev/null & longtermpid=$!
+
+#
+# process data file which has just finished...
+#
+function process () {
+    dom=$1
+    local pid=`cat /tmp/mjb.$$.${dom}.pid`
+    local testnm=`cat /tmp/mjb.$$.${dom}.test`
+    wait ${pid}
+    local ts=$?
+    local line="${testnm} `date '+%s'`"
+
+    if (( ${ts} == 100 )); then
+        # duplicate test ignore...
+        echo "hi" > /dev/null
+    elif (( ${ts} == 101 )); then
+        # timeout
+        echo "${line} ${dom} ERROR: TIMEOUT"
+    elif (( ${ts} == 102 )); then
+        # test not found
+        echo "${line} ${dom} ERROR: TEST NOT FOUND"
+    elif (( ${ts} == 103 )); then
+        # usage error
+        echo "${line} ${dom} ERROR: USAGE"
+    elif (( ${ts} > 0 )); then
+        echo "${line} ${dom} ERROR: failed (${ts}):" \
+`cat /tmp/mjb.$$.${dom}.out`
+    else
+        echo ${line} `cat /tmp/mjb.$$.${dom}.out`
+    fi
+}
+
+#
+# pick a random test -- tests.txt has the list to pick from...
+#
+function getTestName () {
+    ntests=`wc -l tests.txt | awk '{print $1; }'`
+    let testnum=$(( ( RANDOM % ${ntests} ) + 1 ))
+    sed -n "${testnum}p" tests.txt | awk '{ print $1; }' | tr -d '\n'
+}
+
+#
+# callback when a test is finished...
+#
+# here we do all the work for short term tests...
+#
+# tabulate results, reschedule...
+#
+function schedule () {
+    local doms=$*
+
+    for dom in ${doms}; do
+	if [[ -f /tmp/mjb.$$.${dom}.done ]]; then
+  	    rm -f /tmp/mjb.$$.${dom}.done
+
+	    if [[ -f /tmp/mjb.$$.${dom}.pid ]]; then
+                process ${dom}
+            fi
+            # clean up...
+            rm -f /tmp/mjb.$$.${dom}.*
+
+            # schedule next test...
+	    testnm=`getTestName`
+
+            # FIXME: two doms on the pair...
+	    echo ${testnm} > /tmp/mjb.$$.${dom}.test
+            ./run-test.sh ${testnm} ${dom} /tmp/mjb.$$.${dom}.done > \
+                /tmp/mjb.$$.${dom}.out &
+            echo $! > /tmp/mjb.$$.${dom}.pid
+        fi
+     done
+}
+
+#
+# start tests...
+#
+trap "schedule ${doms}" CHLD
+for dom in ${doms}; do touch /tmp/mjb.$$.${dom}.done; done
+schedule ${doms}
+
+#
+# wait for long term tests to finish...
+#
+wait ${longtermpid}
+longtermpid=0
+trap - CHLD
+
+for dom in ${doms}; do 
+    if [[ -f /tmp/mjb.$$.${dom}.pid ]]; then
+        wait `cat /tmp/mjb.$$.${dom}.pid`
+        process ${dom}
+        rm -f /tmp/mjb.$$.${dom}.*
+    fi
+done
+
--- new-run.sh	Sun Mar  6 21:29:47 2005
+++ new-run.sh	Tue Aug 31 00:55:35 2004
@@ -0,0 +1,19 @@
+#!/bin/bash
+
+#
+# newrun.sh, get a new mjb collection
+# run filename...
+#
+if [[ ! -d mjb-output ]]; then
+    mkdir mjb-output
+fi
+
+if [[ ! -f mjb-output/run.num ]]; then
+    echo '0' > mjb-output/run.num
+fi
+
+let num=$(( `cat mjb-output/run.num` ))
+let next=$(( ${num} + 1 ))
+echo ${next} > mjb-output/run.num
+
+printf 'mjb-output/%05d.dat\n' ${next}
--- open-test.c	Sun Mar  6 21:29:47 2005
+++ open-test.c	Tue Aug 31 00:28:20 2004
@@ -0,0 +1,59 @@
+/* open-test.c, open and close the driver...
+ */
+#include <stdio.h>
+#include <string.h>
+
+#include <sys/time.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+/* t2 - t1 in s */
+static double diffsec(const struct timeval *t1, const struct timeval *t2) {
+   long long usec1 = t1->tv_usec + t1->tv_sec * 1000000LL;
+   long long usec2 = t2->tv_usec + t2->tv_sec * 1000000LL;
+   return (double) (usec2 - usec1) * 1e-6;
+}
+
+static double timeOpen(const char *path) {
+   struct timeval start, done;
+   int fd;
+
+   gettimeofday(&start, NULL);
+   if ((fd=open(path, O_RDWR))<0) {
+      perror("open-test: open");
+      return -1;
+   }
+   gettimeofday(&done, NULL);
+   close(fd); 
+   return diffsec(&start, &done);
+}
+
+int main(int argc, char *argv[]) {
+   char path[128];
+
+   if (argc!=2 || strlen(argv[1])!=3) {
+      fprintf(stderr, "usage: open-test CWD\n");
+      return 1;
+   }
+
+   {  int ms, i;
+      const int cnt = 100;
+      double sum = 0;
+
+      snprintf(path, sizeof(path), "/dev/dhc%cw%cd%c", argv[1][0],
+ 	argv[1][1], argv[1][2]);
+
+      ms = (int) (timeOpen(path)*1000);
+
+      for (i=0; i<cnt; i++) {
+         const double v = timeOpen(path);
+         if (v<0) return 1;
+         sum+=v; 
+      }
+      sum*=1000;
+      printf("%s %d %d %d\n", argv[1], ms, (int) sum, cnt);
+   }
+
+   return 0;
+}
+
--- quiet-results.sh	Sun Mar  6 21:29:47 2005
+++ quiet-results.sh	Thu Sep 23 20:09:50 2004
@@ -0,0 +1,15 @@
+#!/bin/bash
+
+#
+# quiet-results.sh, easy one, are they all zero?
+#
+awk '{ print $4; }' $1 | grep -v '^0$' >& /dev/null
+
+if (( $? == 0 )); then
+    echo "all values should be zero and we got:"
+    awk '{ print $4}' $1 | sort | uniq | grep -v '^0$'
+    exit 1
+else
+    exit 0
+fi
+
--- quiet-test.sh	Sun Mar  6 21:29:47 2005
+++ quiet-test.sh	Thu Sep 23 20:08:30 2004
@@ -0,0 +1,30 @@
+#!/bin/bash
+
+#
+# quiet-test.sh, quiet dom, is it really quiet?
+#
+# output: nbytes
+# 
+source /usr/local/share/domhub-tools/common.sh
+#exec 2> /dev/null
+cmdpid=0
+function atexit () { 
+    rm -f /tmp/qt.$$.*;
+    if (( ${cmdpid} != 0 )); then
+        kill ${cmdpid}
+    fi
+}
+trap atexit EXIT
+
+dom=$1
+
+dd if=`getDev ${dom}` of=/tmp/qt.$$.out count=1000 bs=4096 >& /dev/null &
+cmdpid=$!
+
+sleep 60
+kill ${cmdpid}
+wait ${cmdpid}
+cmdpid=0
+
+echo ${dom} `wc -c /tmp/qt.$$.out | awk '{ print $1; }'`
+
--- results-common.sh	Sun Mar  6 21:29:47 2005
+++ results-common.sh	Fri Oct 15 00:38:37 2004
@@ -0,0 +1,31 @@
+#
+# results-common.sh, common routines for all results
+#
+function paired-doms() {
+	local doms=`awk '/^versions / { print $3; }' ${DBFILE} | \
+		tr '\n' ' ' | sed 's/ $//1'`
+	local dom
+	local pdoms=""
+	for dom in ${doms}; do
+		pdom=`echo ${dom} | tr '[AB]' '[BA]'`
+		if echo ${doms} | grep ${pdom} >& /dev/null; then
+			pdoms="${pdoms} ${dom}"
+		fi 
+	done
+	echo ${pdoms}
+}
+
+function unpaired-doms() {
+        local doms=`awk '/^versions / { print $3; }' ${DBFILE} | \
+                tr '\n' ' ' | sed 's/ $//1'`
+        local dom
+        local pdoms=""
+        for dom in ${doms}; do
+                pdom=`echo ${dom} | tr '[AB]' '[BA]'`
+                if ! echo ${doms} | grep ${pdom} >& /dev/null; then
+                        pdoms="${pdoms} ${dom}"
+                fi 
+        done
+        echo ${pdoms}
+}
+
--- results-qry.sh	Sun Mar  6 21:29:47 2005
+++ results-qry.sh	Fri Oct 15 00:37:20 2004
@@ -0,0 +1,88 @@
+#!/bin/bash
+
+#
+# results-qry.sh, query results in a mjb run...
+#
+if (( $# < 2 )); then
+    echo "usage: `basename $0` [-q] dbfile (all|tests...)"
+    exit 1
+fi
+
+function atexit() { rm -f /tmp/resq.$$.*; }
+trap atexit EXIT
+
+#
+# deal with command line options...
+#
+verbose=0
+while /bin/true; do
+	if [[ $1 == "-v" ]]; then
+		shift
+		verbose=1
+	else
+		break
+	fi
+done	
+
+function inform() {
+    local nc=`printf '%s' "$1" | wc -c | awk '{ print $1;}'`
+    printf '%s ' "$1"
+    local i
+    for ((i=0; i<70-${nc}; i++)); do printf '.'; done
+    printf ' '
+}
+
+#
+# check for any errors...
+#
+inform 'Check for Errors'
+if grep 'ERROR' $1 >& /tmp/resq.$$.err; then
+    echo "FAIL"
+    awk '{ print "FAIL> " $0; }' /tmp/resq.$$.err
+    exit 1
+fi
+echo "pass"
+
+#
+# get list of tests in this run...
+#
+awk '{ print $1; }' $1 | sort | uniq > /tmp/resq.$$.tests
+
+#
+# expand list of tests for which to get results...
+#
+dbfile=$1
+shift
+if [[ $1 == "all" ]]; then
+     tests=`lessecho *-results.sh | tr ' ' '\n' | sed 's/\-results\.sh$//1'`
+else
+     tests="$*"
+fi
+
+#
+# run tests...
+#
+ret=0
+for test in ${tests}; do
+    inform "Checking ${test}"
+    # is this a real test?
+    if grep "^${test}\$" /tmp/resq.$$.tests >& /dev/null; then
+        filenm="/tmp/resq.$$.filenm"
+        grep "^${test} " ${dbfile} > ${filenm}
+    else
+	echo "n/a"
+	continue
+    fi
+    if ! DBFILE=$1 ./${test}-results.sh ${filenm} >& /tmp/resq.$$.out; then
+        echo "FAIL"
+        awk '{ print "FAIL> " $0; }' /tmp/resq.$$.out
+	ret=1
+    else
+        echo "pass"
+        if (( ${verbose} > 0 )); then
+    	    awk '{ print "   " $0 }' /tmp/resq.$$.out
+        fi
+    fi 
+done
+
+exit $ret
--- run-mjb.sh	Sun Mar  6 21:29:47 2005
+++ run-mjb.sh	Fri Oct 15 21:53:49 2004
@@ -0,0 +1,60 @@
+#!/bin/bash
+
+#
+# run-mjb.sh
+#
+function atexit() {
+	rm -f /tmp/run-mjb.$$.*
+}
+trap atexit EXIT
+
+if (( $# == 0 )); then
+	results="/tmp/run-mjb.$$.mjb"
+	echo "run-mjb: using temporary results file ${results}"
+elif (( $# != 1 )); then
+	echo "usage: run-mjb [results-file]"
+	exit 1
+else
+	results=$1
+fi
+
+#
+# convert results to absolute path so we can cd...
+#
+if ! echo ${results} | grep '^/' >& /dev/null; then
+	results="`pwd`/${results}"
+fi
+
+#
+# change to install directory...
+# 
+cd /usr/local/share/domhub-testing
+
+#
+# run mjb.sh
+#
+echo "run-mjb: power cycling..."
+(off all && on all) >& /dev/null
+
+doms=`find /proc/driver/domhub -name is-communicating -exec cat {} \; |
+	awk '{ print $2 $4 $6; }'`
+
+if (( ${#doms} == 0 )); then
+	echo "run-mjb: no communicating doms found..."
+	exit 1
+fi
+
+echo "run-mjb: running mjb, check back in 6 hours..."
+if ! ./mjb.sh -h 6 all > ${results}; then
+	echo "run-mjb: mjb data collection failed..."
+	exit 1
+fi
+
+echo "run-mjb: analyzing results file: ${results}"
+if ! ./results-qry.sh ${results} all; then
+	echo "run-mjb: test failed"
+	exit 1
+fi
+
+echo "run-mjb: turning off doms..."
+off all
--- run-test.sh	Sun Mar  6 21:29:48 2005
+++ run-test.sh	Mon Sep 13 21:31:43 2004
@@ -0,0 +1,95 @@
+#!/bin/bash
+
+#
+# run-test.sh, run a test...
+#
+# input: $1=test to run, $2=dom to run it on,
+#   $3 is the filename of the file to touch when done...
+#
+# output:
+#   exit status:
+#      0 normal
+#      1-99 returned from test run
+#      100 duplicate test -- ignore
+#      101 timeout
+#      102 test not found
+#      103 usage error
+#
+source /usr/local/share/domhub-tools/common.sh
+exec 2> /tmp/rt.$$.err
+
+if (( $# != 3 )); then
+    echo "usage: run-test test dom touchfile"
+    exit 103
+fi
+
+timeout=`sed -n "/^$1 /p" tests.txt | awk '{ print $2; }'`
+if (( ${#timeout} == 0 )); then
+    # by default, you have 1 minute to finish...
+    timeout=60
+fi
+
+#
+# cleanup when done...
+#
+testpid=0
+watchdogpid=0
+donefile=$3
+function atexit () {
+    if (( $testpid != "0" )); then
+	massacre ${testpid}	
+    fi
+
+    if (( $watchdogpid != "0" )); then
+        massacre ${watchdogpid}
+    fi
+
+    rm -f /tmp/rt.$$.*
+
+    touch ${donefile}
+}
+trap atexit EXIT
+
+#
+# get mode...
+#
+mode=`sed -n "/^$1 /p" tests.txt | awk '{ print $3; }'`
+if (( ${#mode} == 0 )); then
+    mode="iceboot"
+fi
+
+#
+# set mode...
+#
+${mode} $2 >& /dev/null
+
+#
+# start test...
+#
+./$1-test.sh $2 & testpid=$!
+
+#
+# start watchdog...
+#
+( sleep ${timeout}; massacre ${testpid} ) & watchdogpid=$!
+
+#
+# wait for test...
+#
+wait ${testpid}
+teststatus=$?
+testpid=0
+massacre ${watchdogpid}
+wait ${watchdogpid}
+watchdogpid=0
+
+if (( ${teststatus} > 127 )); then
+    exit 101
+fi
+
+if (( ${teststatus} > 0 )); then
+    cat /tmp/rt.$$.err
+fi
+
+exit $teststatus
+
--- sink-results.sh	Sun Mar  6 21:29:48 2005
+++ sink-results.sh	Fri Oct 15 00:38:37 2004
@@ -0,0 +1,9 @@
+#!/bin/bash
+
+v=`awk '{ print $8; }' $1 | sort -n -r | sed -n '1p'`
+
+if (( $v > 1 )); then
+	echo "sink: too many crc errors"
+	exit 1
+fi
+
--- sink-test.sh	Sun Mar  6 21:29:48 2005
+++ sink-test.sh	Mon Jan  3 22:41:36 2005
@@ -0,0 +1,72 @@
+#!/bin/bash
+
+#
+# sink-test.sh, sink data on the dom, does blocking
+# work?
+#
+# output: procfile_dom_id iceboot_dom_id
+# 
+source /usr/local/share/domhub-tools/common.sh
+#exec 2> /dev/null
+
+dom=$1
+if [[ $2 == "" ]]; then
+    pktsiz=64
+else
+    pktsiz=$2
+fi
+
+#
+# reset com stats...
+#
+card=`getCard ${dom}`
+pair=`getPair ${dom}`
+d=`getDOM ${dom}`
+procfile="/proc/driver/domhub/card${card}/pair${pair}/dom${d}/comstat"
+
+echo 'reset' > ${procfile}
+
+#
+# sink routine...
+#
+# rcv: type addr count
+# addr free zero
+#
+if ! printf 'send ": sink-pkt rcv drop free drop drop ;\r"\nexpect "^> "\n' |
+        se ${dom} >& /dev/null; then
+    exit 1
+fi
+
+#
+# start sinking...
+#
+if ! printf 'send "20000 0 ?DO sink-pkt LOOP\r"\nsleep 1\n' | \
+        se ${dom} >& /dev/null; then
+    exit 2
+fi
+
+#
+# start sending -- capture elapsed time...
+#
+et=`/usr/bin/time \
+    dd if=/dev/zero of=/dev/dhc${card}w${pair}d${d} bs=${pktsiz} count=20000 2>&1 | \
+    sed -n '3p' | awk '{ print $3; }' | tr -d '[a-z]' | tr ':' ' ' | tr '.' ' '`
+etms=`echo ${et} | awk '{ print $1 * 60 * 1000 + $2 * 1000 + $3 * 10; }'`
+
+#
+# does the prompt come back?
+#
+if ! printf 'send "\r"\nexpect "^> "\n' | se ${dom} >& /dev/null; then
+    exit 3
+fi
+
+let v=$(( 20000 * ${pktsiz} ))
+#
+# dom [# messages] [# bytes] [elapsed time]
+#
+retx=`cat ${procfile} | tr ' ' '\n' | tr '=' ' ' | awk '/^RESENT / { print $2; }
+'`
+err=`cat ${procfile} | tr ' ' '\n' | tr '=' ' ' | awk '/^BADPKT / { print $2; }'
+`
+echo ${dom} 20000 ${v} ${etms} ${retx} ${err}
+
--- sink-till-fail.pl	Sun Mar  6 21:29:48 2005
+++ sink-till-fail.pl	Mon Jan  3 22:41:36 2005
@@ -0,0 +1,30 @@
+#!/usr/bin/perl
+
+# sink-till-fail.pl
+# John Jacobsen, NPX Designs, Inc., jacobsen\@npxdesigns.com
+# Started: Thu Dec 30 21:22:42 2004
+
+package MY_PACKAGE;
+use strict;
+
+print "Welcome to $0.\n";
+
+sub usage { return "Usage: $0 <dom>\nE.g. $0 00A\n\n"; }
+
+my $dom = shift;
+my $pktsiz = shift;
+$pktsiz = 64 unless defined $pktsiz;
+die usage unless defined $dom;
+while(1) {
+    my $sinkcmd = "./sink-test.sh $dom $pktsiz";
+    print "$sinkcmd: ";
+    my $result = `$sinkcmd`;
+    print $result;
+    last if $result =~ /timeout/i;
+# 30A 20000 1280000 21190 0 0
+    last unless $result =~ /(\S+) \d+ \d+ \d+ \d+ \d+/;
+}
+
+
+__END__
+
--- slow-open-test.sh	Sun Mar  6 21:29:48 2005
+++ slow-open-test.sh	Tue Aug 31 00:28:20 2004
@@ -0,0 +1,10 @@
+#!/bin/bash
+
+#
+# slow-open-test.sh how long does it take to
+# do an open of the comm driver file...
+#
+# output: [1st open time] [avg open time (100 in a row)]
+# 
+exec ./open-test $1
+
--- softboot-results.sh	Sun Mar  6 21:29:48 2005
+++ softboot-results.sh	Thu Sep 23 20:09:50 2004
@@ -0,0 +1,15 @@
+#!/bin/bash
+
+#
+# softboot-results.sh, easy one, are they all zero?
+#
+awk '{ print $5; }' $1 | grep -v '^0$' >& /dev/null
+
+if (( $? == 0 )); then
+    echo "all values should be zero and we got:"
+    awk '{ print $5}' $1 | sort | uniq | grep -v '^0$'
+    exit 1
+else
+    exit 0
+fi
+
--- softboot-test.sh	Sun Mar  6 21:29:48 2005
+++ softboot-test.sh	Mon Sep 13 21:31:05 2004
@@ -0,0 +1,19 @@
+#!/bin/bash
+
+#
+# domid-test.sh, do domids match -- are they valid -- are
+# there any duplications?
+#
+# output: procfile_dom_id iceboot_dom_id
+# 
+errs=0
+for (( i=0; i<10; i++ )); do
+    softboot $1 | grep ' iceboot$' >& /dev/null
+    status=$?
+    if (( ${status} != 0 )); then
+       let errs=$(( ${errs} + 1 ))
+    fi
+done
+
+echo $1 $i $errs
+
--- source-results.sh	Sun Mar  6 21:29:48 2005
+++ source-results.sh	Fri Oct 15 00:38:37 2004
@@ -0,0 +1,9 @@
+#!/bin/bash
+
+v=`awk '{ print $8; }' $1 | sort -n -r | sed -n '1p'`
+
+if (( $v > 1 )); then
+	echo "source: too many crc errors"
+	exit 1
+fi
+
--- source-test.sh	Sun Mar  6 21:29:48 2005
+++ source-test.sh	Thu Sep 23 20:08:12 2004
@@ -0,0 +1,72 @@
+#!/bin/bash
+
+#
+# source-test.sh, source data on the dom, does blocking
+# work on the dom?
+#
+# output: procfile_dom_id iceboot_dom_id
+# 
+source /usr/local/share/domhub-tools/common.sh
+#exec 2> /dev/null
+
+dom=$1
+
+#
+# reset com stats...
+#
+card=`getCard ${dom}`
+pair=`getPair ${dom}`
+d=`getDOM ${dom}`
+procfile="/proc/driver/domhub/card${card}/pair${pair}/dom${d}/comstat"
+
+echo 'reset' > ${procfile}
+
+#
+# source routine...
+#
+# send: type addr count send
+# addr free zero
+#
+if ! printf 'send ": src-pkt 0 $01000000 596 send ;\r"\nexpect "^> "\n' |
+        se ${dom} >& /dev/null; then
+    exit 1
+fi
+
+#
+# start sourcing...
+#
+if ! printf 'send "7000000 usleep 2250 0 ?DO src-pkt LOOP\r"\nsleep 1' | \
+        se ${dom} >& /dev/null; then
+    exit 2
+fi
+
+#
+# sink data...
+#
+#res=`./sink $dom`
+et=`/usr/bin/time \
+    dd of=/dev/null if=/dev/dhc${card}w${pair}d${d} bs=4096 count=2250 2>&1 | \
+    sed -n '3p' | awk '{ print $3; }' | tr -d '[a-z]' | tr ':' ' ' | tr '.' ' '`
+etms=`echo ${et} | awk '{ print $1 * 60 * 1000 + $2 * 1000 + $3 * 10; }'`
+
+if (( $? != 0 )); then
+    exit 4
+fi
+
+#
+# does the prompt come back?
+#
+if ! printf 'send "\r"\nexpect "^> "\n' | se ${dom} >& /dev/null; then
+    exit 3
+fi
+
+let v=$(( 2250 * 596 ))
+#
+# dom [# messages] [# bytes] [elapsed time]
+#
+retx=`cat ${procfile} | tr ' ' '\n' | tr '=' ' ' | awk '/^RESENT / { print $2; }
+'`
+err=`cat ${procfile} | tr ' ' '\n' | tr '=' ' ' | awk '/^BADPKT / { print $2; }'
+`
+echo ${dom} 2250 ${v} ${etms} ${retx} ${err}
+
--- t	Sun Mar  6 21:29:48 2005
+++ t	Sun Mar  6 21:29:47 2005
@@ -0,0 +1 @@
+pscreate: directories not supported yet...
--- tcal-results.sh	Sun Mar  6 21:29:48 2005
+++ tcal-results.sh	Fri Nov 19 01:46:01 2004
@@ -0,0 +1,23 @@
+#!/bin/bash
+
+#
+# check tcal test results...
+#
+v=`awk '{ print $5; }' $1 | sort -n -r | sed -n 1p | sed 's/\..*//1'`
+if (( "$v" > 4 )); then
+	echo "tcal: round trip rms is too big: ${v}"
+	exit 1
+fi 
+
+if (( `awk '{ print $8; }' $1 | sort -n | uniq | wc -l | awk '{ print $1; }'` \
+      != 1 )); then
+	echo "tcal: dom tx - rx clocks is not always the same"
+	exit 1
+fi
+
+if (( `awk '{ print $8; }' $1 | sort -n | uniq` != 610 )); then
+	echo "tcal: dom tx - rx clocks is not always 610"
+	exit 1
+fi
+
+
--- tcal-test.sh	Sun Mar  6 21:29:48 2005
+++ tcal-test.sh	Fri Nov 19 01:46:01 2004
@@ -0,0 +1,40 @@
+#!/bin/bash
+
+#
+# tcal-test.sh, short tcal test, assume doms are
+# not in configboot...
+#
+# run time is about 20-30s, output is: 
+#   dom round_trip_time(ns) round_trip_rms(ns) dom_tx_rx_time(clocks) 
+#     min_round_trip_time max_round_trip_time
+#
+source /usr/local/share/domhub-tools/common.sh
+exec 2> /dev/null
+
+dom=$1
+
+function atexit() {
+    rm -f /tmp/tct.$$.*
+}
+trap atexit EXIT
+
+#
+# usage...
+#
+if (( $# != 1 )); then
+   nm=`basename $0`
+   echo "usage: ${nm} CWD"
+   exit 1
+fi
+
+if ! tcalcycle -n 1000 ${dom} > /tmp/tct.$$.out; then
+    echo "`basename $0`: unable to run tcalcycle..."
+    exit 1
+fi 
+
+clks=`egrep '^dom_[rt]x_time' /tmp/tct.$$.out | sed -n '1,2p' | \
+    awk '{ print $2; } END { print " - p q"}' | dc`
+
+cat /tmp/tct.$$.out | tcal-kalle -m | \
+    awk -vdom=${dom} -vclks=${clks} '{ print dom " " $0 " " clks; }'
+
--- temp-test.sh	Sun Mar  6 21:29:48 2005
+++ temp-test.sh	Tue Aug 31 00:28:20 2004
@@ -0,0 +1,10 @@
+#!/bin/bash
+
+#
+# temp-test.sh
+#
+# output: temperature in degrees C
+# 
+echo $1 `printf 'send "readTemp prtTemp\r"\nexpect "^> "\n' | \
+    se $1 | grep '^temperature: ' | awk '{ print $2; }'`
+
--- testcb.sh	Sun Mar  6 21:29:48 2005
+++ testcb.sh	Tue Aug 31 00:28:20 2004
@@ -0,0 +1,144 @@
+#!/bin/bash
+
+#
+# testcb.sh, test configboot -- power cycle is part of
+# the test so we lose access to both doms on the pair...
+#
+PATH=${PATH}:/usr/arm-elf/bin
+
+card=1
+pair=1
+dom=${card}${pair}A
+
+#
+# testcb.sh, test configboot...
+#
+if (( $# != 1 )); then
+    echo "usage: testcb.sh nloops"
+    exit 1
+fi
+
+cp -fl ../../dom-fpga/stf/ComEPXA4DPM/simpletest.sbi iceboot.sbi
+
+#
+# power cycle...
+#
+off $card $pair && sleep 1 && on $card $pair
+
+for (( i=0; i<$1; i++ )); do
+    #
+    # create a release.hex file...
+    #
+    dd if=/dev/urandom of=1.bin bs=1024 count=100 >& /dev/null
+    dd if=/dev/urandom of=2.bin bs=1024 count=100 >& /dev/null
+    dd if=/dev/urandom of=3.bin bs=1024 count=100 >& /dev/null
+    dd if=/dev/urandom of=4.bin bs=1024 count=100 >& /dev/null
+    dd if=/dev/urandom of=5.bin bs=1024 count=100 >& /dev/null
+    dd if=/dev/urandom of=6.bin bs=1024 count=100 >& /dev/null
+    dd if=/dev/urandom of=7.bin bs=1024 count=100 >& /dev/null
+    dd if=/dev/urandom of=8.bin bs=1024 count=100 >& /dev/null
+    dd if=/dev/urandom of=9.bin bs=1024 count=100 >& /dev/null
+    dd if=/dev/urandom of=10.bin bs=1024 count=100 >& /dev/null
+    (cd ..; /bin/bash mkrelease.sh epxa10/bin/iceboot.bin.gz \
+	testing/iceboot.sbi \
+	../iceboot/resources/startup.fs \
+	testing/1.bin testing/2.bin testing/3.bin testing/4.bin \
+	testing/5.bin testing/6.bin testing/7.bin testing/8.bin \
+	testing/9.bin testing/10.bin 2> /dev/null ) > /tmp/mkr.out
+
+    cks=`egrep '^[a-f0-9]*[ ]*flash.dump$' /tmp/mkr.out | \
+	sed 's/ .*$//1'`
+	
+    echo "cks=$cks"
+
+    if (( ${#cks} != 32 )); then 
+	echo "testcb.sh: unable to create release.hex"
+	exit 1
+    fi
+
+    #
+    # make sure we made it into iceboot...
+    #
+    if [[ `(cd ../domhub-tools; ./domstate.sh ${dom}) | awk '{print $2; }'` \
+		!= "configboot" ]]; then
+	echo "testcb.sh: ${dom} is not in configboot"
+	exit 1
+    fi
+
+    #
+    # every other loop swap a and b...
+    #
+    if (( $i % 2 == 1 )); then
+	#
+	# swap a and b
+	#
+	if ! printf 'send "b"\nexpect "^  Swap flash A and B"\n' | \
+		se ${dom}; then
+	    echo "testcb.sh: unable to swap a and b flash chips"
+	    exit 1
+	fi
+    fi
+
+    #
+    # start flash burn...
+    #
+    if ! ( cd ../domhub-tools; ./insrel.sh ../release.hex ${dom} ); then
+	echo "testcb.sh: unable to install release.hex"
+	rm -f ../release.hex
+	exit 1
+    fi
+
+    rm -f ../release.hex
+
+    #
+    # get checksum
+    #
+    cat <<EOF > /tmp/tc.$$.se
+send "s\\" md5sum \\" type \$40000000 \$00800000 md5sum type crlf type\\r"
+expect "^md5sum [0-9a-f]+\$"
+EOF
+
+    cks2=`se ${dom} < /tmp/tc.$$.se | tr -d '\r' | grep '^md5sum' | \
+	awk '{print $2;}'`
+
+    rm -f /tmp/tc.$$.se
+
+    #
+    # all good?
+    #
+    if [[ "$cks" != "$cks2" ]]; then
+	echo "failure on loop: $i"
+	echo "  cks=${cks}, burned=${cks2}."
+	exit 1
+    fi
+
+    #
+    # power cycle...
+    #
+    off $card $pair && sleep 1 && on $card $pair
+
+cat <<EOF > /tmp/tc.$$.se
+send "s"
+expect "^# "
+send "r"
+expect "^# "
+EOF
+
+    if ! se ${dom} < /tmp/tc.$$.se; then
+	echo "testcb.sh: unable to boot serial"
+	exit 1
+    fi
+
+    rm -f /tmp/tc.$$.se
+done
+
+off $card $pair
+
+rm -f iceboot.sbi
+rm -f [0-9]*.bin
+
+
+
+
+
+
--- tests.txt	Sun Mar  6 21:29:48 2005
+++ tests.txt	Tue Oct 12 20:37:02 2004
@@ -0,0 +1,13 @@
+tcal 100 iceboot
+echo 300 echo-mode
+wr-block 200 echo-mode
+domid 30 iceboot
+softboot 500 iceboot
+fpga-reload 500 iceboot
+slow-open 200 iceboot
+temp 20 iceboot
+sink 300 iceboot
+source 120 iceboot
+echo-throttle 600 echo-mode
+current 200 iceboot
+quiet 120 iceboot
--- throughput-AB.sh	Sun Mar  6 21:29:48 2005
+++ throughput-AB.sh	Fri Oct 15 00:38:37 2004
@@ -0,0 +1,84 @@
+#!/bin/bash
+
+source throughput-common.sh
+
+function atexit () {
+    rm -f /tmp/thrAB.$$.doms
+}
+trap atexit EXIT
+
+#
+# throughput-AB.sh, get results of throughput
+# tests for A/B doms...
+#
+
+#
+# FIXME: check interrupt, times stats -- interrupts, and times are
+# (approx) per wire pair...
+#
+
+#
+# for the paired doms
+#
+# we use 3*sigma for a cutoff (p value around 0.005)...
+#
+sigma=42
+mean=86012
+pdoms=`paired-doms`
+for dom in ${pdoms}; do
+	cl=`printf '$3 ~ /^%s$/ { print $0; }' $dom`
+	awk "${cl}" $1 | awk -vmean=${mean} -vsigma=${sigma} \
+		'{ if (NF==12) print $4, mean, sigma, "3 * - - p"; }' $1 | \
+		dc | sed 's/\..*$//1' | sort -n | uniq > \
+		/tmp/thrAB.$$.pslowest
+
+        if (( `wc -l /tmp/thrAB.$$.pslowest | awk '{ print $1; }'` > 0 )); then
+            if (( `head -1 /tmp/thrAB.$$.pslowest` < 0 )); then
+	        echo "`basename $0`: paired dom ${dom} is too slow"
+	        exit 1
+            fi
+        fi
+done
+
+sigma=13
+mean=89923
+udoms=`unpaired-doms`
+for dom in ${udoms}; do
+        cl=`printf '$3 ~ /^%s$/ { print $0; }' $dom`
+        awk "${cl}" $1 | awk -vmean=${mean} -vsigma=${sigma} \
+                '{ if (NF==12) print $4, mean, sigma, "3 * - - p"; }' | \
+		dc | sed 's/\..*$//1' | sort -n | uniq > \
+		/tmp/thrAB.$$.uslowest
+        if (( `wc -l /tmp/thrAB.$$.uslowest | awk '{ print $1; }'` > 0 )); then
+            if (( `head -1 /tmp/thrAB.$$.uslowest` < 0 )); then
+                echo "`basename $0`: unpaired dom ${dom}, is too slow"
+		cat /tmp/thrAB.$$.uslowest
+                exit 1
+            fi
+        fi
+done
+
+#
+# check echo test error count
+#
+if (( `awk '{ print $5; }' $1 | sort -n -r | uniq | sed -n '1p'` > 0 )); then
+	echo "`basename $0`: too many echo test errors"
+	exit 1
+fi
+
+#
+# check for crc errors...
+#
+if (( `awk '{ print $7; }' $1 | sort -n -r | uniq | sed -n '1p'` > 1 )); then
+	echo "`basename $0`: too many crc errors"
+	exit 1
+fi
+
+#
+# check for retxs...
+#
+if (( `awk '{ print $6; }' $1 | sort -n -r | uniq | sed -n '1p'` > 0 )); then
+	echo "`basename $0`: too many retxs"
+	exit 1
+fi
+
--- throughput-all-results.sh	Sun Mar  6 21:29:48 2005
+++ throughput-all-results.sh	Fri Oct 15 00:37:05 2004
@@ -0,0 +1,88 @@
+#!/bin/bash
+
+source throughput-common.sh
+source results-common.sh
+
+function atexit () {
+    rm -f /tmp/thrall.$$.doms
+}
+trap atexit EXIT
+
+#
+# throughput-all-results.sh, get results of throughput
+# tests on all doms...
+#
+
+#
+# FIXME: for all doms, select err and retx and criterion...
+#
+
+#
+# FIXME: check interrupt, times stats -- interrupts, and times are
+# (approx) per wire pair...
+#
+
+#
+# for the paired doms
+#
+# we use 3*sigma for a cutoff (p value around 0.005)...
+#
+sigma=92
+mean=46050
+pdoms=`paired-doms`
+for dom in ${pdoms}; do
+	cl=`printf '$3 ~ /^%s$/ { print $0; }' $dom`
+	awk "${cl}" $1 | awk -vmean=${mean} -vsigma=${sigma} \
+		'{ if (NF==12) print $4, mean, sigma, "3 * - - p"; }' $1 | \
+		dc | sed 's/\..*$//1' | sort -n | uniq > \
+		/tmp/thrall.$$.pslowest
+
+        if (( `wc -l /tmp/thrall.$$.pslowest | awk '{ print $1; }'` > 0 )); then
+            if (( `head -1 /tmp/thrall.$$.pslowest` < 0 )); then
+	        echo "throughput-all: paired dom ${dom} is too slow"
+	        exit 1
+            fi
+        fi
+done
+
+sigma=14
+mean=89919
+udoms=`unpaired-doms`
+for dom in ${udoms}; do
+        cl=`printf '$3 ~ /^%s$/ { print $0; }' $dom`
+        awk "${cl}" $1 | awk -vmean=${mean} -vsigma=${sigma} \
+                '{ if (NF==12) print $4, mean, sigma, "3 * - - p"; }' | \
+		dc | sed 's/\..*$//1' | sort -n | uniq > \
+		/tmp/thrall.$$.uslowest
+        if (( `wc -l /tmp/thrall.$$.uslowest | awk '{ print $1; }'` > 0 )); then
+            if (( `head -1 /tmp/thrall.$$.uslowest` < 0 )); then
+                echo "throughput-all: unpaired dom ${dom}, is too slow"
+                exit 1
+            fi
+        fi
+done
+
+#
+# check echo test error count
+#
+if (( `awk '{ print $5; }' $1 | sort -n -r | uniq | sed -n '1p'` > 0 )); then
+	echo "throughput-all: too many echo test errors"
+	exit 1
+fi
+
+#
+# check for crc errors...
+#
+if (( `awk '{ print $7; }' $1 | sort -n -r | uniq | sed -n '1p'` > 1 )); then
+	echo "throughput-all: too many crc errors"
+	exit 1
+fi
+
+#
+# check for retxs...
+#
+if (( `awk '{ print $6; }' $1 | sort -n -r | uniq | sed -n '1p'` > 0 )); then
+	echo "throughput-all: too many retxs"
+	exit 1
+fi
+
--- throughput-common.sh	Sun Mar  6 21:29:48 2005
+++ throughput-common.sh	Thu Sep 23 20:09:50 2004
@@ -0,0 +1,5 @@
+#
+# throughput-common.sh, routines used in the
+# throughput results scripts...
+#
+
--- throughput.sh	Sun Mar  6 21:29:48 2005
+++ throughput.sh	Thu Sep 23 20:07:49 2004
@@ -0,0 +1,66 @@
+#!/bin/bash
+
+#
+# throughput.sh:
+#
+#  dom nbytes seconds nretx ncrcerrs sys-time user-time
+#
+source /usr/local/share/domhub-tools/common.sh
+doms=`getDomList $*`
+
+function atexit () {
+    rm -f /tmp/thr.$$.*
+}
+trap atexit EXIT
+
+function totalInterrupts () {
+    ncpu=`cat /proc/interrupts | sed -n 1p | awk '{ print NF; }'`
+    cat /proc/interrupts | egrep '^[ ]*[0-9]+\:' | \
+        awk -vncpu=${ncpu} '{ for (i=0; i<ncpu; i++) print $(i+2); }' | \
+        sed '1!s/$/ +/1' | awk '{ print $0; } END { print "p"; }' | dc
+}
+
+# collect baseline stats...
+interrupts="`totalInterrupts` `sleep 30` `totalInterrupts`"
+intrate=`echo "${interrupts} r - 1 k 30 / p" | dc`
+
+# reset comm stats...
+for dom in ${doms}; do
+    card=`getCard ${dom}`
+    pair=`getPair ${dom}`
+    d=`getDOM ${dom}`
+    procfile="/proc/driver/domhub/card${card}/pair${pair}/dom${d}/comstat"
+    echo 'reset' > ${procfile}
+done
+
+sints=`totalInterrupts`
+if ! time -p ./echo-test -n 1000 ${doms} \
+        1> /tmp/thr.$$.out 2> /tmp/thr.$$.times; then
+    exit 1
+fi
+
+#
+# compute throughput...
+#
+awk '{ print $2, $3, "1 k / p"}' /tmp/thr.$$.out | dc > /tmp/thr.$$.tp
+
+eints=`totalInterrupts`
+rtime=`sed -n 1p /tmp/thr.$$.times | awk '{ print $2; }'`
+stime=`sed -n 3p /tmp/thr.$$.times | awk '{ print $2; }'`
+sperc=`echo "$stime $rtime 4 k / 100 * p" | dc`
+utime=`sed -n 2p /tmp/thr.$$.times | awk '{ print $2; }'`
+uperc=`echo "$utime $rtime 4 k / 100 * p" | dc`
+nintrate=`echo "${eints} ${sints} - 1 k ${rtime} / ${intrate} - p" | dc`
+
+for dom in ${doms}; do
+    retx=`cat ${procfile} | tr ' ' '\n' | tr '=' ' ' | \
+        awk '/^RESENT / { print $2; }'`
+    err=`cat ${procfile} | tr ' ' '\n' | tr '=' ' ' | \
+        awk '/^BADPKT / { print $2; }'`
+
+    echo `paste -d ' ' /tmp/thr.$$.out /tmp/thr.$$.tp | grep "^${dom} " | \
+awk '{ print $1, $5, $4; }'` \
+${retx} ${err} ${intrate} ${nintrate} \
+${rtime} ${sperc} ${uperc}
+done
+
--- validate.sh	Sun Mar  6 21:29:48 2005
+++ validate.sh	Tue Aug 31 00:28:20 2004
@@ -0,0 +1,90 @@
+#!/bin/bash
+
+#
+# validate.sh, attempt to validate dor/dom firmware and
+# software...
+#
+source /usr/local/share/domhub-tools/common.sh
+exec 2> /dev/null
+
+# we need job control on...
+set -m
+RANDOM=0
+
+#
+# cleanup...
+#
+rm -f /tmp/val.$$.*
+longtermpid=0
+function atexit() {
+    if (( ${longtermpid} != 0 )); then
+        kill ${longtermpid}
+        longtermpid=0
+    fi
+
+    for pidf in `find /tmp -name 'val.$$.*.pid' -print | tr '\n' ' ' `; do
+        pid=`cat ${pidf}`
+	echo "killing ${pid}..."
+        massacre ${pid}
+        echo "waiting for ${pid}..."
+        wait ${pid} 
+    done
+    rm -f /tmp/val.$$.*
+}
+trap "atexit" EXIT
+
+function usage () { 
+    echo "usage: `basename $0` release.hex"
+    exit 1
+}
+
+if (( $# != 1 )); then usage; fi
+
+if [[ ! -f $1 ]]; then
+   echo "`basename $0`: unable to find release file $1"
+   exit 1
+fi
+
+release=$1
+
+#
+# first make sure we can burn a release...
+#
+echo "installing release ${release}" >> validate.log
+if ! insall ${release} >& /tmp/val.$$.insall; then
+    echo "validate.sh: unable to install release.hex on all doms, log file:"
+    cat /tmp/val.$$.insall
+    rm -f /tmp/val.$$.insall
+    exit 1
+fi
+
+rm -f /tmp/val.$$.insall
+
+#
+# move doms into iceboot and get version info
+#
+echo "getting versions" >> validate.log
+versions ${doms} > /tmp/val.$$.out
+vdoms=`awk '{ print $1; }' /tmp/val.$$.out | tr '\n' ' '`
+
+if (( ${#doms} != ${#vdoms} )); then
+   echo "`basename $0`: can not find version info for all doms"
+   awk '{ print "    found> " $0; }' /tmp/val.$$.out
+   exit 1
+fi
+
+#
+# FIXME: run long echo/tcal test...
+#
+
+#
+# run mjb test...
+#
+echo "mjb test starts..." >> validate.log
+if ! ./mjb.sh -s 599 all; then
+    echo "`basename $0`: unable to run mjb"
+    exit 1
+fi
+
+echo "done" >> validate.log
+
--- wiggle-test.sh	Sun Mar  6 21:29:48 2005
+++ wiggle-test.sh	Sat Oct  9 00:05:03 2004
@@ -0,0 +1,24 @@
+#!/bin/bash
+
+#
+# wiggle-test.sh
+#
+# output: nothing!
+# 
+source /usr/local/share/domhub-tools/common.sh
+
+dom=$1
+card=`getCard ${dom}`
+pair=`getPair ${dom}`
+d=`getDOM ${dom}`
+
+printf 'send "no-comm wiggle\r"\nsleep 5\n' | se ${dom} >& /dev/null
+sleep 60
+echo 'reset' > \
+	/proc/driver/domhub/card${card}/pair${pair}/dom${d}/is-communicating
+if ! printf 'send "\r"\nexpect "^> "\n' | se ${dom} >& /dev/null; then
+    exit 1
+fi
+
+echo ${dom}
+
--- wr-block-test.sh	Sun Mar  6 21:29:48 2005
+++ wr-block-test.sh	Mon Sep 13 21:30:18 2004
@@ -0,0 +1,50 @@
+#!/bin/bash
+
+#
+# wr-block-test.sh, test dor write blocking...
+#
+# push data to doms in echo mode, but don't read
+# it back.  wait until the fifos are plugged and
+# retx goes nuts, then stop pushing data, close the
+# connection and try to reopen, how long does it
+# take to reconnect...
+#
+source /usr/local/share/domhub-tools/common.sh
+#exec 2> /dev/null
+
+dom=$1
+
+testpid=0
+function atexit () {
+    if (( ${testpid} != 0 )); then
+        kill ${testpid}
+    fi
+}
+trap atexit EXIT
+
+#
+# start them up...
+#
+dd if=/dev/zero of=`getDev $1` bs=64 count=10000 >& /dev/null & testpid=$!
+
+#
+# wait for queues to fill up...
+#
+sleep 30
+
+#
+# stop pushing data...
+#
+kill ${testpid}
+wait ${testpid}
+testpid=0
+
+#
+# measure reopen time...
+#
+starttm=`date '+%s'`
+printf 'send "hi there"\nexpect "hi there"\n' | se ${dom} >& /dev/null
+endtm=`date '+%s'`
+let diff=$(( ${endtm} - ${starttm} ))
+echo ${dom} ${diff}
+
